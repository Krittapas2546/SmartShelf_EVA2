from fastapi import FastAPI
import uvicorn
from fastapi.staticfiles import StaticFiles
import pathlib
import socket
import os
import signal
import subprocess
import json
import httpx
import asyncio
# --- Import Routers ‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á ---
from api import jobs, websockets

# ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô FastAPI ‡∏´‡∏•‡∏±‡∏Å
app = FastAPI(
    title="Smart Shelf API (Refactored)",
    description="A professional, well-structured server for the Smart Shelf system.",
    version="3.0.0"
)

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö
async def initialize_shelf_info():
    """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô get_shelf_info_endpoint ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å HTTP"""
    try:
        print("üîÑ Initializing shelf information...")
        # Import ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        from api.jobs import get_shelf_info_endpoint
        
        # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å HTTP
        result = await get_shelf_info_endpoint()
        
        if result.get("success"):
            shelf_id = result.get("shelf_id")
            shelf_name = result.get("shelf_name")
            print(f"‚úÖ Shelf initialized: {shelf_id} ({shelf_name})")
            return True
        else:
            print(f"‚ö†Ô∏è Failed to initialize shelf info: {result.get('error', 'Unknown error')}")
            return False
    except Exception as e:
        print(f"‚ùå Error initializing shelf info: {e}")
        return False

async def initialize_shelf_layout():
    """‡∏î‡∏∂‡∏á layout configuration ‡∏à‡∏≤‡∏Å Gateway ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö"""
    try:
        print("üîÑ Initializing shelf layout from Gateway...")
        
        # Import ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        from api.jobs import fetch_layout_from_gateway, GLOBAL_SHELF_INFO
        from core.database import update_layout_from_gateway
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ shelf_id ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        shelf_id = GLOBAL_SHELF_INFO.get("shelf_id")
        if not shelf_id:
            print("‚ö†Ô∏è No shelf_id available, using default PC2")
            shelf_id = "PC2"
            
        # ‡∏î‡∏∂‡∏á layout ‡∏à‡∏≤‡∏Å Gateway
        layout_data = await fetch_layout_from_gateway(shelf_id)
        
        if layout_data and layout_data.get("status") == "success":
            gateway_layout = layout_data.get("layout", {})
            
            if gateway_layout:
                # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï local database configuration
                update_success = update_layout_from_gateway(gateway_layout)
                
                if update_success:
                    print(f"‚úÖ Layout initialized from Gateway: {len(gateway_layout)} positions")
                    return True
                else:
                    print("‚ö†Ô∏è Failed to update local database with Gateway layout")
                    return False
            else:
                print("üìù Empty layout from Gateway, using default configuration")
                return False
        else:
            print("‚ùå Failed to fetch layout from Gateway")
            return False
            
    except Exception as e:
        print(f"‚ùå Error initializing layout: {e}")
        return False

async def initialize_shelf_state():
    """‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô shelf state ‡∏à‡∏≤‡∏Å Gateway ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö"""
    try:
        print("üîÑ Initializing shelf state from Gateway...")
        
        # Import ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        from api.jobs import restore_shelf_state_from_gateway, GLOBAL_SHELF_INFO
        from core.database import DB
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ shelf_id ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if not GLOBAL_SHELF_INFO.get("shelf_id"):
            print("‚ö†Ô∏è No shelf_id available, skipping shelf state restore")
            return False
            
        # ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡∏à‡∏≤‡∏Å Gateway
        restored_state = await restore_shelf_state_from_gateway()
        
        if restored_state and isinstance(restored_state, dict):
            print(f"‚úÖ Shelf state restored from Gateway: {len(restored_state)} positions")
            
            # ‡πÅ‡∏õ‡∏•‡∏á Gateway format ‡πÄ‡∏õ‡πá‡∏ô local DB format
            # ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ restored_state = {"L1B1": {...}, "L1B2": {...}}
            restored_count = 0
            for position_key, position_data in restored_state.items():
                # Parse position (L1B1 -> level=1, block=1)
                import re
                match = re.match(r'L(\d+)B(\d+)', position_key)
                if match:
                    level = int(match.group(1))
                    block = int(match.group(2))
                    lots = position_data.get("lots", [])
                    
                    # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï local DB
                    for cell in DB["shelf_state"]:
                        if cell[0] == level and cell[1] == block:
                            cell[2] = lots
                            restored_count += 1
                            break
            
            print(f"üì¶ Updated {restored_count} positions in local database")
            return True
            
        else:
            print("üìù No shelf state data from Gateway, using current local state")
            return True
            
    except Exception as e:
        print(f"‚ùå Error initializing shelf state: {e}")
        return False

@app.on_event("startup")
async def startup_event():
    """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô initialization ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"""
    # ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô (‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡∏á)
    await asyncio.sleep(1)
    
    # Migration: ‡πÄ‡∏û‡∏¥‡πà‡∏° biz field ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö lots ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
    from core.database import migrate_existing_lots_add_biz
    migrate_existing_lots_add_biz()
    
    # Initialize shelf info first
    shelf_init_success = await initialize_shelf_info()
    
    # Initialize layout configuration from Gateway
    layout_init_success = await initialize_shelf_layout()
    
    # Then initialize shelf state (requires shelf_id and layout)
    if shelf_init_success:
        await initialize_shelf_state()
    else:
        print("‚ö†Ô∏è Skipping shelf state initialization due to shelf info failure")
        
    # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£ initialization
    print("=" * 50)
    print("üöÄ System Initialization Summary:")
    print(f"   üìã Shelf Info: {'‚úÖ' if shelf_init_success else '‚ùå'}")
    print(f"   üèóÔ∏è  Layout: {'‚úÖ' if layout_init_success else '‚ùå'}")
    print(f"   üì¶ State: Available after shelf info")
    print("=" * 50)


STATIC_PATH = pathlib.Path(__file__).parent / "static"
app.mount("/static", StaticFiles(directory=STATIC_PATH), name="static")


app.include_router(jobs.router)
app.include_router(websockets.router)



# --- Main ---
if __name__ == "__main__":
    # --- Kill any existing process on port 8000 before starting ---
    def kill_port_process(port=8000):
        """Kill process using specified port (optimized for Linux)"""
        try:
            import platform
            system = platform.system().lower()
            
            if system == "linux" or system == "darwin":  # Linux/macOS
                print(f"ÔøΩ Checking for processes on port {port} (Linux/Unix)...")
                
                # Method 1: Try lsof (most reliable)
                try:
                    result = subprocess.run(f"lsof -t -i:{port}", shell=True, 
                                         capture_output=True, text=True, timeout=5)
                    pids = [p.strip() for p in result.stdout.strip().split() if p.strip().isdigit()]
                    
                    if pids:
                        for pid in pids:
                            try:
                                print(f"üîå Found process {pid} on port {port}. Terminating...")
                                os.kill(int(pid), signal.SIGTERM)
                                print(f"üî™ Process {pid} terminated successfully.")
                            except (ValueError, ProcessLookupError) as e:
                                print(f"‚ö†Ô∏è Process {pid} already terminated: {e}")
                    else:
                        print(f"‚úÖ No processes found on port {port}")
                        
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    # Method 2: Fallback to netstat + kill
                    print("ÔøΩ Using netstat fallback method...")
                    result = subprocess.run(f"netstat -tlnp | grep :{port}", shell=True,
                                         capture_output=True, text=True)
                    if result.stdout:
                        print(f"ÔøΩ Found service on port {port}, attempting graceful shutdown...")
                        subprocess.run(f"sudo fuser -k {port}/tcp", shell=True)
                        print(f"üî™ Port {port} cleared.")
                    else:
                        print(f"‚úÖ No processes found on port {port}")
                        
            elif system == "windows":
                # Windows fallback (simplified)
                print(f"ü™ü Checking for processes on port {port} (Windows)...")
                result = subprocess.run(f'netstat -ano | findstr ":{port}"', 
                                      shell=True, capture_output=True, text=True)
                
                pids = set()
                for line in result.stdout.strip().split('\n'):
                    if line.strip() and f":{port}" in line:
                        parts = line.split()
                        if len(parts) >= 5 and parts[-1].isdigit():
                            pids.add(parts[-1])
                
                if pids:
                    for pid in pids:
                        try:
                            print(f"üîå Terminating Windows process {pid}...")
                            subprocess.run(f"taskkill /F /PID {pid}", shell=True, check=True)
                            print(f"üî™ Process {pid} terminated.")
                        except subprocess.CalledProcessError as e:
                            print(f"‚ö†Ô∏è Could not terminate process {pid}: {e}")
                else:
                    print(f"‚úÖ No processes found on port {port}")
                    
        except Exception as e:
            print(f"‚ùå Error while checking port {port}: {e}")
    
    # Kill any existing process on port 8000
    kill_port_process(8000)

    def get_local_ip():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 8000))
                return s.getsockname()[0]
        except:
            return "localhost"
    
    local_ip = get_local_ip()
    
    print("üöÄ Starting RFID Smart Shelf Server (v2.0 Refactored)...")
    print(f"üì± Smart Shelf UI: http://localhost:8000")
    print(f"python /home/pi/Documents/GitHub/RFID-smart-shelf/RFID-smart-shelf/src/main.py")
    print(f"üéÆ Event Simulator: http://localhost:8000/simulator")
    print(f"üìÑ API Docs:       http://localhost:8000/docs")
    print(f"üåê Network API:    http://{local_ip}:8000") 
    print(f"üì± Pi Access:      http://{local_ip}:8000")  
    uvicorn.run(app, host="0.0.0.0", port=8000)